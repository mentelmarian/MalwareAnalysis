imul eax, [ebp+ecx*i+var_20] is like eax = eax*(array - 4bytes + i*4)
which at the first iteration -> i=1 -> eax = eax*(array - 4bytes + 4bytes), so it
points to the first element of the array
var_20 represented as a variable is just a pointer (this is a trick)
Also remeber that short loops may be unrolled by the compiler

Second phase answer

1st loop:
eax = 1
eax++ => eax = 2
ecx = 1
eax = 2*array[i-1] => eax = 2
edx = 1
check if array[1] == 2

2nd loop 
eax = 2
eax++ => eax = 3
ecx = 2
eax = 3*array[2-1] => eax = 6
edx = 2
check if array[2] == 6

3rd loop
eax = 3
eax++ => eax = 4
ecx = 3
eax = 4*array[i-1] => eax = 24
edx = 3
check if array[2] == 24

4th loop
eax = 4
eax++ => eax = 5
ecx = 4
eax = 5*array[i-1] => eax = 120
edx = 4
check if array[4] == 120

5th loop
i = 5
eax = 6
eax = 6*array[5-1] = 720
check if array[5] == 720

o05km1 because he takes the input[i] and uses it to calculate the offset
for generating the string "giants"

Phase 6
1 ? ? ? ? ?
first number 1<=x<=6
second must be different from first
third must be different from first
fourth must be different from first
fifth must be different from first
sixth must be different from first
-> every number must be different from previous ones